;;;
"title": "Separation of Concerns with&nbsp;Git",
"seo_title": "Separation of Concerns with Git: Public Repos vs. Private Repos",
"date": "2016-08-07 14:33 UTC",
"abstract": [
	"At times, we may need to keep certain files off a particlar repo. Usually a .gitignore file would suffice. But what if we want those files to be present in another repo? How do we go about setting that up?",
	"I will present a short method that tackles this problem."
]
;;;

<article>
	<p>When developing a web app or site that has a public-facing repo, there may be a need to have some rudimentary separation of concerns where git is concerned. Certain files that we may want on the production server might seem out of place on the public repo due to licensing, privacy or security concerns.</p>
	<p>This method presumes that there are three repos: <strong>production</strong>, <strong>public</strong> and <strong>local/development</strong>. We will be attempting to prevent some sensitive files from being pushed to the public repo, while allowing them to be sent off to produciton.</p>
	<p>To solve this problem, we first add dummies of the sensitive files to the development repo. These dummy files can be empty files, as long as they have the same names as the actual sensitive files we will eventually add.</p>
	<p>We will commit the dummy files, then replace them with the actual sensitive files. Now we tell git to assume that the files we have just added have not changed.</p>
	<p>This initial setup can be accomplished by running the following commands in the console:</p>
<pre class="code-block"><code><span class="code-comment"># Create and commit the dummy file(s)</span>
<span class="prompt">$ </span>touch /path/to/sensitive_file
<span class="prompt">$ </span>git commit -am "Add dummy file"

<span class="code-comment"># Replace the dummy file(s) with the real one(s)</span>
<span class="prompt">$ </span>rm -rf /path/to/sensitive_file
<span class="prompt">$ </span>mv /path/to/actual/sensitive_file /path/to/sensitive_file

<span class="code-comment"># Tell git to act like nothing happened</span>
<span class="prompt">$ </span>git update-index --assume-unchanged /path/to/sensitive_file</code></pre>
	<p><strong>NOTE:</strong> <code>/path/to/actual/sensitive_file</code> must be in the .gitignore or outside of the git project. Otherwise, it beats the point of this whole process.</p>
	<p>From now on, git should skip over the sensitive files whenever it is checking for diffs. Thus, we can push normally to the <strong>public</strong> repo where the dummy files reside, while the actual sensitive files remain in our <strong>development</strong> repo.</p>
	<p>To push the sensitive files to the <strong>production</strong> repo, we will take the following steps:</p>
	<ol class="u-list">
		<li>Tell git to no longer assume the files are unchanged.</li>
		<li>Commit the sensitive files, and push them to production.</li>
		<li>Tell git, within the scope of our development repo, to go back one commit. Essentially, we undo the previous commit, but only <strong>locally</strong>.</li>
		<li>Remind git to assume the sensitive files have not changed.</li>
	</ol>
	<p>These 4 steps can be packaged into a script, which we will run whenever we want to push some changes to production.</p>
	<p>An example script is presented below, with the following assumptions:</p>
	<ul class="u-list">
		<li>We have some licensed web fonts that we shouldn't distribute on our public repo.</li>
		<li>We want the font files to reside on the same server as our web app/site rather than on a dedicated font server.</li>
		<li>Our production sever is hosted on <strong>Heroku</strong>.</li>
	</ul>
<pre class="code-block"><code><span class="code-comment"># Array with paths to font files</span>
FONT_LIST="assets/fonts/title-font.woff
assets/fonts/title-font.woff2
assets/fonts/body-font.woff
assets/fonts/body-font.woff2"

<span class="code-comment"># STEP 1</span>
for FONT in FONT_LIST
do
	git update-index --no-assume-unchanged $FONT
done

<span class="code-comment"># STEP 2</span>
git commit -am "Push font files to server"
git push -f heroku master

<span class="code-comment"># STEP 3</span>
git reset HEAD~1

<span class="code-comment"># STEP 3 & 4</span>
for FONT in FONT_LIST
do
	git reset HEAD $FONT <span class="code-comment"># STEP 3 continued</span>
	git update-index --assume-unchanged $FONT <span class="code-comment"># STEP 4</span>
done</code></pre>
	<p>The are some minor downsides to using this method:</p>
	<ul class="u-list">
		<li>The git logs on our production server will always show the "Push font files to server" as the most recent commit. In other words, production will be one commit ahead of the development.</li>
		<li>As a result, we must run this script anytime we want to push changes to production.</li>
		<li>The script will include unstaged changes in the commit that it generates. It is advisable to make sure that there are no pending changes in the master branch before running the script.</li>
	</ul>
	<p>However, I would argue that these are inconsequential inconveniences.</p>
	<p>To reiterate, we will now use a different command to push to production.</p>
<pre class="code-block"><code><span class="code-comment"># OLD command to push to production</span>
<span class="prompt">$ </span>git push heroku master

<span class="code-comment"># NEW command to push to production
# Assuming we save the script to the root of our project
# and name it "deploy"</span>
<span class="prompt">$ </span>sh deploy</code></pre>
	<p>The method described in this post was used on this very site to keep the web font files out of the <a href="https://github.com/Croccifixio/blog">public GitHub repository.</a> As of 14<sup>th</sup> March 2017, the font files are now hosted on a CDN. The process of setting that up will be described in a future blog post.</p>
</article>